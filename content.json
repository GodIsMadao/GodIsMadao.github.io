{"meta":{"title":"GodIsMadao's blog","subtitle":"Fighting!","description":"Talk is Cheap","author":"Saint Yun","url":"http://saintyun.cn"},"pages":[{"title":"about","date":"2017-04-12T05:45:39.000Z","updated":"2017-04-12T05:56:51.000Z","comments":true,"path":"about/index.html","permalink":"http://saintyun.cn/about/index.html","excerpt":"","text":"菜鸟程序员～三分种热度～懒癌晚期～爱dota～爱折腾～爱篮球～单身🐶～rua～"},{"title":"canvas","date":"2017-05-10T09:11:02.000Z","updated":"2017-05-10T09:16:42.000Z","comments":true,"path":"canvas/index.html","permalink":"http://saintyun.cn/canvas/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-04-12T05:39:09.000Z","updated":"2017-04-12T05:40:49.000Z","comments":true,"path":"categories/index.html","permalink":"http://saintyun.cn/categories/index.html","excerpt":"","text":""},{"title":"photo","date":"2017-04-06T08:46:29.000Z","updated":"2017-05-10T09:18:04.000Z","comments":true,"path":"photo/index.html","permalink":"http://saintyun.cn/photo/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-04-12T05:34:25.000Z","updated":"2017-04-12T05:36:14.000Z","comments":true,"path":"tags/index.html","permalink":"http://saintyun.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"canvas-catch the cat","slug":"canvas-catch-the-cat","date":"2017-05-10T09:18:54.000Z","updated":"2017-05-17T06:53:42.000Z","comments":true,"path":"2017/05/10/canvas-catch-the-cat/","link":"","permalink":"http://saintyun.cn/2017/05/10/canvas-catch-the-cat/","excerpt":"引言好久没写博客了,今天来写下上个星期花了几天时间做的这个web端的canvas游戏—-抓猫游戏 游戏介绍首先,这个游戏是前几年出来的,比较火的一个游戏,虽然我没玩过,最近访问网站时,不小心404了,在404界面有了一个这个flash做的游戏如图","text":"引言好久没写博客了,今天来写下上个星期花了几天时间做的这个web端的canvas游戏—-抓猫游戏 游戏介绍首先,这个游戏是前几年出来的,比较火的一个游戏,虽然我没玩过,最近访问网站时,不小心404了,在404界面有了一个这个flash做的游戏如图游戏的玩法就是每次点击图中不是灰点的圆点,猫都会走一步,如果猫最终走出图,则失败;若你用灰色点将猫困住,则成功. 思考 首先,图中圆点的构建,我准备用canvas来绘制 其次,对于圆点的记数,是用坐标[0,1]这种还是0,1,2这种 对于圆点的数据结构建模 圆点的寻路算法探索过程先思考数据结构,用什么数据结构呢?多点,有最短路径,有闭环,当然就是图了,二叉树肯定不行.什么图?看一下游戏玩法,普通的一个点可以向周围6个方向发散,而且可以返回,那就是一个无权无向图了.什么最短路径算法?最简单的有dfs(Depth First Search)与bfs(Breadth First Search),当然还有Dijkstra算法,A star算法,稍微了解了下,后面两个主要针对有权图,当然无权也可以,之后可以去试一下,这里我用的是bfs算法圆点怎么个走法?有哪些规律?要将可通过的边界点记录下来,寻找到边界点的最短路径和下一步的走法;普通圆点a(假设是11*11的矩阵),如果是在奇数行的话(第一行为0行),他的6个下一节点位置和在偶数行的下一个节点位置不同,如图上图的14号节点是在第1行里的,他的左上是14-11=3,左是14-1=13,左下是14+11=25,右上是14-10=4,右是14+1=15,右下是14+12=26在如下图上图的26号节点是在第1行里的,他的左上是26-12=14,左是26-1=25,左下是26+10=36,右上是26-11=15,右是26+1=27,右下是26+11=37用什么语言呢? 先准备用python,后来想想算了,既然放页面上还是用js去实现了以前数据结构课上学过,图有两种实现方式,一种是邻接表的形式,每个节点后面跟着一个记录者该节点可以到达的下一个节点的数组;还有一种是邻接矩阵的形式,每个节点代表矩阵的横向以及纵向的点,x,y=0的话,则代表x与y之间不连通;x,y=1的话(无权,如果有权的话,则是权值),则代表x与y之间连通,所以一般无向图的都是对称的,中间斜对角线是无穷大,代表自己到自己的距离不可达.这里我用了邻接数组,二维数组来实现无权无向图图有顶点Vertex类,还有Graph类,Graph里主要有一些图内自带的属性以及函数方法,比如新增边addEdge,新增节点addVertex,删除节点removeVertex以及init初始化,随机生成灰色点等,闲话少说上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284// 构建图// 顶点类function Vertex(label)&#123; this.label = label; // this.distance = distance;&#125;// 图类function Graph(v)&#123; this.vertices = v; this.edges = 0; this.adj = []; this.marked = [] // 二维邻接数组初始化 for(var i = 0;i&lt;this.vertices;++i)&#123; this.adj[i] = []; // this.adj[i].push(\"\"); this.marked[i] = false; &#125; this.edgeTo = []; this.addEdge = addEdge; this.showGraph = showGraph; // 深度优先算法 this.listBorder = listBorder; this.dfs = dfs; this.removeVertex = removeVertex; this.init = init; this.bfs = bfs; this.getpath=getpath this.num = num; this.remarker = remarker;&#125;function addEdge(v, w) &#123; this.adj[v].push(w); this.adj[w].push(v); this.edges++;&#125;function removeVertex(v)&#123; // 1.删除v的邻接表的邻接表里的v this.adj[v].forEach(function(value)&#123; for(var w=0;w&lt;this.adj[value].length;++w)&#123; if(this.adj[value][w] == v)&#123; this.adj[value].splice(w,1); &#125; &#125; &#125;,this) //2.删除v的邻接表 this.adj[v].splice(0,this.adj[v].length);&#125;//indexof自定义数组构建indexof方法,判断某个元素是不是在数组里存在Array.prototype.indexOf = function(el)&#123; for (var i=0,n=this.length; i&lt;n; i++)&#123; if (this[i] === el)&#123; return i; &#125; &#125; return -1;&#125;//显示图,打印function showGraph()&#123; for (var i = 0; i &lt; this.vertices; ++i) &#123; str = i + \"-&gt;\"; for (var j = 0; j &lt; this.vertices; ++j) &#123; if (this.adj[i][j] != undefined) str += this.adj[i][j] + ' '; &#125; console.log(str) &#125;&#125;//深度优先function dfs(v)&#123;// 用于输出的 if 语句在这里不是必须的 this.marked[v] = true; if (this.adj[v] != undefined) // console.log(\"visit vertex:\"+v) this.adj[v].forEach(function(value) &#123; if (!this.marked[value]) &#123; this.dfs(value); &#125; &#125;, this);&#125;// m * m =v 初始化function init(m)&#123; var v = m*m; for(var i=0;i&lt;v;i++)&#123; // 去重复 // 判断奇数行还是偶数行 if(i+1&lt;v&amp;&amp;i%m!=m-1)&#123; this.addEdge(i,i+1); &#125; if(i-1&gt;=0&amp;&amp;i%m!=0)&#123; this.addEdge(i,i-1); &#125; if(i-m&gt;=0)&#123; this.addEdge(i,i-m); &#125; if(i-m+1&gt;=0&amp;&amp;i-m+1&gt;=Math.floor(i/m)*m)&#123; this.addEdge(i,i-m+1); &#125; if(i+m&lt;v)&#123; this.addEdge(i,i+m); &#125; if(Math.floor(i/m)%2==0)&#123; if(i+m-1&lt;v&amp;&amp;i%m!=0)&#123; this.addEdge(i,i+m-1); &#125; &#125;else if(Math.floor(i/m)%2==1)&#123; if(i+m+1&lt;v&amp;&amp;i%m!=m-1)&#123; this.addEdge(i,i+m+1); &#125; &#125; &#125; //1.去重复操作 for(var i=0;i&lt;v;i++)&#123; this.adj[i] = this.adj[i].unique(); &#125; // 2.初始化时，从邻接数组里random m+1个，放入数组，遍历数组 remove m+1个顶点，变为不可访问 this.num = randomNum(m+1); // console.log(this.num) for (var j=0;j&lt;this.num.length;j++)&#123; this.removeVertex(this.num[j]) &#125;&#125;//Array.prototype.contains = function (obj)&#123; var i = this.length; while (i--) &#123; if (this[i] === obj) &#123; return true; &#125; &#125; return false;&#125;function randomNum(n)&#123; var v = (n-1) *(n-1)-1 var m = [] while(m.length&lt;n)&#123; var number=parseInt(Math.random()*v); if(!m.contains(number)&amp;&amp;number!=60)&#123; m.push(number) arraynum.push(number) &#125; &#125; return m&#125;Array.prototype.unique = function()&#123; var res = [] var json = &#123;&#125; for (var i=0;i&lt;this.length;i++)&#123; if(!json[this[i]])&#123; res.push(this[i]) json[this[i]]=1 &#125; &#125; return res&#125;// 列出边界点的数组function listBorder(m)&#123; for(var i =0;i&lt;m;i++)&#123; if(this.adj[i * m].length!=0) &#123; borderVertext.push(i * m); &#125; if(this.adj[(i + 1) * m - 1].length!=0)&#123; borderVertext.push((i + 1) * m - 1) &#125; &#125; for(var i = 1;i&lt;=m-2;i++)&#123; if(this.adj[i].length!=0)&#123; borderVertext.push(i) &#125; &#125; for(var i=m*(m-1)+1;i&lt;=m*m-1;i++)&#123; if(this.adj[i].length!=0)&#123; borderVertext.push(i); &#125; &#125;&#125;//再列出到边界点的最短距离算法// 使用bfs求解无权无向图的最短路径// a为当前点的位置// length数组，路径或者得出下一步的最优解数组//广度优先//把最短路径和长度给我算出来function bfs(s)&#123; arrlength[s] = 0 isInPath.splice(0) var queue = [];//队列 this.marked[s] = true; queue.push(s); //添加到队尾,如果用unshift则会由右往左遍历，显示0 2 1 3 4 while(queue.length &gt; 0)&#123; var v = queue.shift();//从队首移除 isInPath.push(v) if(typeof(v) != 'string')&#123; // console.log(\"Visited vertex:\" + v); &#125;; for(var w of this.adj[v])&#123; if(!this.marked[w])&#123; this.edgeTo[w] = v; arrlength[w] = arrlength[v]+1 this.marked[w] = true; queue.push(w); &#125; &#125; &#125;&#125;//复位markerfunction remarker() &#123; for(var i =0;i&lt;this.vertices;i++)&#123; this.marked[i] = false; &#125;&#125;//每次点击的时候,调用,获取最短路径以及下一步点function getpath(arr,local)&#123;// 宽度优先,他相同length 的 path是同级的?// 找到第一个属于bordervertex的即可 var count; var minlength = arrlength[borderVertext[0]]; var minindex = 0; // console.log(arrlength) /* * todo 会有问题 * */ for(var i=1;i&lt;borderVertext.length;i++)&#123; if(minlength&gt;arrlength[borderVertext[i]]) &#123; minlength = arrlength[borderVertext[i]]; minindex = i; &#125; &#125; console.log(borderVertext) console.log(\"minidnex:\"+minindex+\" minnum:\"+borderVertext[minindex]) console.log(\"minlength:\"+minlength) console.log(arrlength) for(var i=0;i&lt;arr.length;i++)&#123; //不能使用第一个,第一个不一定是最优解 //需要找到最短长度的那个边缘节点 if(arr[i]==borderVertext[minindex])&#123; count = arr[i]; break; &#125; &#125; while(this.edgeTo[count]!=local&amp;&amp;this.edgeTo[count]!=undefined)&#123; count = this.edgeTo[count] &#125; if(count!=undefined)&#123; return count &#125;else&#123; return -1 &#125;&#125;// 数据填入 0~120个顶点// 1.首先121个点都默认//testvar borderVertext = []var arraynum = []//已经点击的点var num = []// var dfsarr = []// //记录每一层的个数// var floorcount = []//最短长度var arrlength = []//最短路径var path = []var isInPath = []// var nextNode// var finalNodenum canvas实现核心的算法实现就上面所说,当然我们还得用canvas去实现他,在canvas实现的过程中也有一些坑. 每次点击的重绘过程如何实现 小猫图片的移动或者变换如何实现首先,需要对你所点击的canvas做监听操作,需要在callback函数里面做判断,如果点击的在绿色点区域内,则重绘,否则不做操作.其次,小猫图片我首先想到的也用canvas来做,后来发现行不通,无法实现变换和移动操作,后来干脆直接用html的image标签来做,对其的position进行dom操作,并且一同放在canvas的监听事件里面.上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259/** * Created by Saintyun on 2017/5/12. */var container = document.getElementById(\"container\")var tips = document.getElementById(\"tips\")document.write(returnCitySN[\"cip\"]+','+returnCitySN[\"cname\"])var timer = document.getElementById(\"timer\")function startop()&#123; var speed = 0.2; var start = self.setInterval(function()&#123; container.style.opacity = speed.toString(); speed+=0.2; console.log(speed) if(speed&gt;=1)&#123; window.clearInterval(start) &#125; &#125;,200)&#125;function endop()&#123; var speed = parseInt(container.style.opacity); var end = setInterval(function()&#123; container.style.opacity = speed.toString(); speed-=0.2; console.log(speed) if(speed&lt;=0)&#123; window.clearInterval(end) location.reload() &#125; &#125;,200)&#125;window.onload = function()&#123; startop()&#125;var g = new Graph(121);// 定义当前猫的位置的数组var localvertex = 60var prevertexg.init(11);g.listBorder(11);var canvas = document.getElementById(\"canvas\")var ctx = canvas.getContext('2d')var circle = &#123; x: 64, y: 64, r: 20&#125;var imagelocation = &#123; x: 298, y: 268&#125;var arr = []var myimage = document.getElementById(\"myimage\")myimage.style.position = \"absolute\";myimage.style.left = imagelocation.x + \"px\";myimage.style.top = imagelocation.y + \"px\";myimage.src = '/canvas/image/stand_cat1.png'for (var i = 0; i &lt; 11; i++) &#123; for (var j = 0; j &lt; 11; j++) &#123; if (i % 2 == 0) &#123; arr.push(&#123; x: circle.x + j * (2 * circle.r + 4), y: circle.y + i * (2 * circle.r + 4), r: 20, vertex: i * 11 + j &#125;) &#125; else &#123; arr.push(&#123; x: circle.x + j * (2 * circle.r + 4) + 22, y: circle.y + i * (2 * circle.r + 4), r: 20, vertex: i * 11 + j &#125;) &#125; &#125;&#125;canvas.addEventListener('click', function (e) &#123; p = getEventPosition(e); reDraw(p, ctx);//// console.log(g.num)&#125;, false)// 为了实现循环重绘，所以就要将图形的基本参数事先保存下来// 点击重新绘制//得到点击的坐标function getEventPosition(ev) &#123; var x, y; if (ev.layerX || ev.layerX == 0) &#123; x = ev.layerX; y = ev.layerY; &#125; else if (ev.offsetX || ev.offsetX == 0) &#123; // Opera x = ev.offsetX; y = ev.offsetY; &#125; return &#123;x: x, y: y&#125;;&#125;//重绘function reDraw(p, ctx) &#123; var date1 = new Date().getTime(); var whichObject = []; for (var i = 0; i &lt; arr.length; i++) &#123;// 点击的不在当前 localvertex 圆下 if (p &amp;&amp; (arr[i].x + arr[i].r) &gt;= p.x &amp;&amp; p.x &gt;= arr[i].x - arr[i].r &amp;&amp; (arr[i].y + arr[i].r) &gt;= p.y &amp;&amp; p.y &gt;= arr[i].y - arr[i].r &amp;&amp; i != localvertex&amp;&amp; !g.num.contains(i)) &#123; whichObject.push(i); //每次点击一次,image坐标改变一次 ctx.fillStyle = '#728401'; ctx.beginPath(); ctx.arc(arr[i].x, arr[i].y, arr[i].r, 0, Math.PI * 2, true); ctx.fill(); g.num.push(i)// 还有图片移动的6个方向的情况,第一次点击,反方向情况,之后根据路径来 //然后获取图片移动之后的位置!// 1.记录点击的位置 :i// 2.将其canvas颜色改变,// 3.将其图的顶点去除 相关数组// g.removeVertex(i) if (borderVertext.indexOf(i) != -1) &#123; borderVertext.splice(borderVertext.indexOf(i), 1) &#125;// console.log(borderVertext) g.remarker() if(borderVertext.contains(localvertex))&#123; console.log(\"猫跑出去咯!\") tips.innerHTML = \"额,就差一点,猫跑出去咯!\" myimage.style.display = 'none' &#125;else &#123; g.bfs(localvertex) // nextnode prevertex = localvertex localvertex = g.getpath(isInPath, localvertex)// &#125; if (localvertex != -1) &#123; console.log(\"localvertex:\" + localvertex + \"prevertex:\" + prevertex)// 解决每点击一次,往已点击数组里加// 偶数行奇数行问题// 优化!把imagelocation的操作单独列出6个方向操作 if (localvertex == prevertex + 11) &#123; if (Math.floor(prevertex / 11) % 2 == 0) &#123; //斜向右下 imagelocation = &#123; x: imagelocation.x + 22, y: imagelocation.y + 44 &#125; &#125; else &#123; imagelocation = &#123; x: imagelocation.x - 22, y: imagelocation.y + 44 &#125; &#125; &#125; else if (localvertex == prevertex + 10) &#123;// 斜向左下 imagelocation = &#123; x: imagelocation.x - 22, y: imagelocation.y + 44 &#125; &#125; else if (localvertex == prevertex + 12) &#123; //斜向右下 imagelocation = &#123; x: imagelocation.x + 22, y: imagelocation.y + 44 &#125; &#125; else if (localvertex == prevertex - 12) &#123; // imagelocation = &#123; x: imagelocation.x - 22, y: imagelocation.y - 44 &#125; &#125; else if (localvertex == prevertex + 1) &#123;// 向右 imagelocation = &#123; x: imagelocation.x + 44, y: imagelocation.y &#125; &#125; else if (localvertex == prevertex - 1) &#123;// 向左 imagelocation = &#123; x: imagelocation.x - 44, y: imagelocation.y &#125; &#125; else if (localvertex == prevertex - 11) &#123; if (Math.floor(prevertex / 11) % 2 == 0) &#123;// 斜向右上 imagelocation = &#123; x: imagelocation.x + 22, y: imagelocation.y - 44 &#125; &#125; else &#123; imagelocation = &#123; x: imagelocation.x - 22, y: imagelocation.y - 44 &#125; &#125; &#125; else if (localvertex == prevertex - 10) &#123; imagelocation = &#123; x: imagelocation.x + 22, y: imagelocation.y - 44 &#125; &#125; myimage.style.left = imagelocation.x + \"px\" myimage.style.top = imagelocation.y + \"px\" &#125;else&#123; myimage.src='/canvas/image/catch_cat.png' tips.innerHTML = \"好耶！你抓住猫啦!\" console.log(\"你抓住猫啦!\") &#125; &#125; //注意图片所移动的位置 一定是没有点击过的 √// 到边界时候的处理// 包围起来,没有路走的处理 break; &#125; &#125; // 接下来的问题是如何移动图片,或者是如何消除之前的图片// var date2 = new Date().getTime();// timer.innerHTML += \"draw所耗费时间\"+(date2-date1)+\"ms\"+\"&lt;br/&gt;\"&#125;// 按照i*j = vfor (var i = 0; i &lt; 11; ++i) &#123; for (var j = 0; j &lt; 11; ++j) &#123;// ctx.clearRect(0, 0, canvas.width, canvas.height); if (g.num.contains(i * 11 + j)) &#123; ctx.fillStyle = '#728401'; &#125; else &#123; ctx.fillStyle = '#ccff00'; &#125; if (i % 2 == 0) &#123; ctx.beginPath() ctx.arc(circle.x + j * (2 * circle.r + 4), circle.y + i * (2 * circle.r + 4), circle.r, 0, Math.PI * 2, true) ctx.fill() ctx.beginPath() ctx.fillStyle = 'black' ctx.fillText(i * 11 + j, circle.x + j * (2 * circle.r + 4), circle.y + i * (2 * circle.r + 4)); &#125; else &#123; ctx.beginPath() ctx.arc(circle.x + j * (2 * circle.r + 4) + 22, circle.y + i * (2 * circle.r + 4), circle.r, 0, Math.PI * 2, true) ctx.fill() ctx.beginPath() ctx.fillStyle = 'black' ctx.fillText(i * 11 + j, circle.x + j * (2 * circle.r + 4) + 22, circle.y + i * (2 * circle.r + 4)); &#125; &#125;&#125; 实现的效果实现的效果去这个网站地址就可以去看了,我把部署到vps上了http://saintyun.cn/canvas效果还行的,你可以打开控制台,看下每一步的路径以及目标点,我也没删掉这些,算是个小作弊吧~~~ 优化 寻找下一步的走法时,只是单纯的根据最短路径的第一个值来,如果有多条最短路径,但是A路径的下一个节点a0是有点”自投罗网”的意思,就是a0方向的灰色节点较多,这样就比较容易围住,所以以后可以做个某方向灰色点分布趋势的判断,得出哪一个是最优点 目前只是单机版的,没有排行榜,难度切换,访问用户以及用户ip记录,步数记录,得分转化等功能 代码上冗余的有点多,需要优化下期预告我准备做一些android的ui控件或者效果或者实现一些小框架如网络连接之类的或者如下图所示的效果","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://saintyun.cn/tags/canvas/"}]},{"title":"Android端sqlite以及mqtt client的使用","slug":"android-sqlite-and-mqttclient","date":"2017-04-20T14:00:08.000Z","updated":"2017-04-22T03:20:08.000Z","comments":true,"path":"2017/04/20/android-sqlite-and-mqttclient/","link":"","permalink":"http://saintyun.cn/2017/04/20/android-sqlite-and-mqttclient/","excerpt":"引言昨天不是解决了个模拟器的问题么，今天在检查代码的时候，发现原来的代码里用到了sqlite，以前都是用sharepreference或者application来存储的，application的生命周期在程序启动时开始，在程序彻底销毁时销毁，sharepreference的生命周期开始于程序安装，启动，在程序卸载时销毁，类似于缓存一样的东西。那么好了，刚好来学习下这个sqlite吧。","text":"引言昨天不是解决了个模拟器的问题么，今天在检查代码的时候，发现原来的代码里用到了sqlite，以前都是用sharepreference或者application来存储的，application的生命周期在程序启动时开始，在程序彻底销毁时销毁，sharepreference的生命周期开始于程序安装，启动，在程序卸载时销毁，类似于缓存一样的东西。那么好了，刚好来学习下这个sqlite吧。 sqlite是什么？sqlite是一种轻量级的数据库，我的mac里自动装有sqlite，你可以使用命令行 sqlite3 如果出现下图的结果，则表示电脑里已经装有sqlite。他常用的命令和其他的数据库大同小异，只是语法稍微有些不同 .open ：打开数据库文件(.db).databases:显示当前目录下的数据库.tables:查看数据库下的表.schema:查看表的视图 我把模拟器上的/data/data/&lt;程序名称&gt;/databases/msg.db拷贝到了本地目录下，进行一顿操作，结果如图有个SQLScout的android studio插件，据说很好用，但是很可惜，要收费，还有一个工具，也是可以可视化，暂时还没尝试过，先上链接：http://blog.csdn.net/logicteamleader/article/details/50975607算了，反正我要在真机上测试，也没有root过，不能访问/data/下面的文件，所以就没再进行下去了，就当了解了解了。 sqlite在android上如何操作？操作也是和其他数据库差不多的，也是写sql。Android提供了一个SQLiteOpenHelper类可以继承，可以单独弄个数据库操作类，可以重载他的oncreate方法进行创建table操作，也可自定义写一些方法，根据自己的需求。需要注意的是，主要有两种执行方式，一种是db.execSQL(sql),这种主要针对于insert,update,delete操作；还有一种是db.rawQuery(sql,select[])，后面一项是筛选的条件，如果写在了sql里面的话，就写个null好了。还有一个是cursor的用法 cursor = db.rawQuery(sql, null); if(cursor!=null&amp;&amp;cursor.moveToFirst()) { Log.e(“++++ID+++”, id + “count:” + cursor.getColumnCount()); id = cursor.getInt(0); } MQTT协议这个直接引用书籍了 MQTT(Message Queuing Telemetry Transport,消息队列遥测传输)，是IBM公司开发的一个轻量级的消息传输协议，跟XMPP协议类似，也是基于发布订阅模式实现的即时消息通信，不同的是MQTT协议针对低带宽网络、低计算能力设备等做了特殊的优化，他的设计思想是开源，可靠和简单。 客户端与服务端的选取客户端选用了MQTT-client,服务端选择了apollo,客户端就不介绍了，主要介绍下apache apollo的安装与部署下载地址：http://activemq.apache.org/apollo/download.html选择linux版本的，下载，然后tar -zxvf apache-apollo-1.7.1-unix-distro.tar.gz进行解压然后，选择一个目录，一般是/var/lib，输入${APOLLO_HOME}/bin/apollo create mybroker这里的${APOLLO_HOME}需要在系统的/.bash_profile里面配置之后，\b可以vi mybroker/etc/apollo.xml，进行查看设置，如图如图所示，他的web端口是61680和61681，然后tcp端口是61613，用户名admin,密码password等等之后我们将其run起来，“/Users/saintyun/mybroker/bin/apollo-broker” run然后打开localhost:61680，登陆后，显示如图，有apollo连接数，连接机器ip以及topic主题，以及message好吧，可以愉快的测试了～～～","categories":[{"name":"android","slug":"android","permalink":"http://saintyun.cn/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://saintyun.cn/tags/android/"},{"name":"mqtt","slug":"mqtt","permalink":"http://saintyun.cn/tags/mqtt/"}]},{"title":"在android studio上运行android模拟器碰到的问题","slug":"android-virtual-device-problem","date":"2017-04-19T14:23:19.000Z","updated":"2017-04-19T14:23:19.000Z","comments":true,"path":"2017/04/19/android-virtual-device-problem/","link":"","permalink":"http://saintyun.cn/2017/04/19/android-virtual-device-problem/","excerpt":"引言今天测试机没带回去～～～然后在android studio上用自带的模拟器调试程序，碰到了一些问题，其实有些问题以前也碰到过，只是没有做个总结，过一段时间就忘了，那先把这次碰到的问题先记录下来，之后再慢慢更新","text":"引言今天测试机没带回去～～～然后在android studio上用自带的模拟器调试程序，碰到了一些问题，其实有些问题以前也碰到过，只是没有做个总结，过一段时间就忘了，那先把这次碰到的问题先记录下来，之后再慢慢更新 问题1.在run apk的时候，碰到install_failed_no_matching_abis错误在解答这个问题之前需要了解CPU架构，android是基于linux的操作系统，可支持的CPU架构有 armeabi 第5代 ARM v5TE，使用软件浮点运算，兼容所有ARM设备，通用性强，速度慢armeabi-v7a 第7代 ARM v7，使用硬件浮点运算，具有高级扩展功能arm64-v8a 第8代，64位，包含AArch32、AArch64两个执行状态对应32、64bitx86 intel 32位，一般用于平板x86_64 intel 64位，一般用于平板mips 少接触mips64 少接触 最常见的无非是x86或者x86_64或者arm了。查看所连接设备的cpu信息 进入terminaladb shellcd /proc &amp;&amp; cat cpuinfo 图中所示，有4个，应该是4核心的意思，GenuineIntel意味着是intel家的x86或者x86_64，好吧直接名字就是generic_x86_64～～～回到本问题，报了该错误，是因为CPU架构不匹配，我的虚拟机选择了x86,x86自从用了HAXM加速，支持了模拟器，速度是arm模拟器的10倍左右，很快。但是我的lib里是有引入arm的so文件的好吧～两种办法，一种换个arm的模拟器由于速度实在太慢，而且那个arm的so文件夹都是些高德地图相关的东西，就干脆在gradle里面把其注释掉，不引用就ok了。 问题2.模拟器如何访问本地服务器查看连接android机的ip adb shellifconfig或者getprop获取系统信息，找到[net.gprs.local-ip]: [10.0.2.15]就是模拟器的ip 模拟器不能直接通过127.0.0.1来访问电脑上的本地服务器，需要知道电脑相对于android设备的映射后的地址。 在Android中，将我们本地电脑的地址映射为10.0.2.2，因此，只需要将原先的localhost或者127.0.0.1换成10.0.2.2，就可以在模拟器上访问本地计算机上的Web资源了。 —————分割线——————","categories":[{"name":"android","slug":"android","permalink":"http://saintyun.cn/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://saintyun.cn/tags/android/"}]},{"title":"双核处理问题","slug":"handle-dual-core-problem","date":"2017-04-17T12:25:36.000Z","updated":"2017-05-11T01:11:53.000Z","comments":true,"path":"2017/04/17/handle-dual-core-problem/","link":"","permalink":"http://saintyun.cn/2017/04/17/handle-dual-core-problem/","excerpt":"题目 一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。","text":"题目 一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。 输入描述 输入包括两行：第一行为整数n(1 ≤ n ≤ 50)第二行为n个整数lengthi，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。 输出描述 输出一个整数，表示最少需要处理的时间 输入例子 53072 3072 7168 3072 1024 输出例子 9216 思考首先得理解题意，1s单核可以处理1kb，length数组里面的存放的是一个个长度为1024倍数单位为kb的值，求设计方案，让cpu处理这批任务所需时间最短，就是给一个任务分配的顺序以及给cpu core A还是cpu core B。稍微想一想，我想到了这个东东是不是很像！只不过是两行的俄罗斯方块，尽可能让他的高度最短～～～那么这样就好做了，方案如下 先将数组倒序排序再按顺序分别填入cpu core A(以下用a代替) 和 cpu core B(以下用b代替),每填一个，就判断一下，a的长度和b的长度谁长，判断之后，下一个任务填入短的那个cpu core，就这么下去，最后再判断一下左右两个cpu core,选长的一个作为最终的结果。 解决方案TALK IS CHEAP,SHOW ME THE CODE!最近在学python，机子上没有装c环境，偷个懒，便用python写了1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-#n:个数#length[]：数组n = input(\"n:\")timesA = 0timesB = 0length = []times = 0;for i in range(n): y = input(str(i)+\":\") length.append(y/1024)#先对length数组内容排序length.sort()length.reverse()#比较函数def compare(a,b): if a &gt;= b: return a else: return b#填入动作def send(data): global timesA,timesB if timesA &lt;= timesB: timesA += data else : timesB += datafor item in length: send(item)times = compare(timesA,timesB)print times*1024 最后上个结果图","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://saintyun.cn/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://saintyun.cn/tags/algorithm/"}]},{"title":"在ubuntu下搭建ftp server","slug":"ubuntu-setup-ftp-server","date":"2017-04-16T04:00:28.000Z","updated":"2017-04-17T12:51:46.000Z","comments":true,"path":"2017/04/16/ubuntu-setup-ftp-server/","link":"","permalink":"http://saintyun.cn/2017/04/16/ubuntu-setup-ftp-server/","excerpt":"引言由于想查看访客来源，于是想从vps上下载nginx的log文件做处理分析，所以需要用到ftp服务器进行上传下载，当然，如果是windows的话，有自带的mstsc远程连接（如果远程是windows 的话），也有一些好用的工具，如winscp，securecrt等等，很方便。在mac上，他也有自带的远程连接服务器的工具（⌘+K）。","text":"引言由于想查看访客来源，于是想从vps上下载nginx的log文件做处理分析，所以需要用到ftp服务器进行上传下载，当然，如果是windows的话，有自带的mstsc远程连接（如果远程是windows 的话），也有一些好用的工具，如winscp，securecrt等等，很方便。在mac上，他也有自带的远程连接服务器的工具（⌘+K）。 vps搭建ftp server接下来去vps上搭建ftp服务器。首先，我们得在服务器上下载vsftp sudo apt-get install vsftpd 判断vsftp有没有安装成功 sudo service vsftpd restartvsftpd start/running, process 30757 安装成功，接下来创建该ftp服务器的访问用户 sudo adduser uftp 修改vsftpd.conf,一般是在/etc/vsftpd.conf，具体路径因人而异，可以whereis vsftpd.conf看一下 主要加上以下几点userlist_deny=NOuserlist_enable=YESuserlist_file=/etc/allowed_usersseccomp_sandbox=NO” local_enable=YES userlist_enable=YES，userlist_deny=NO时，userlist_file是个白名单，里面所列出来的用户是可以访问ftp服务器的。接下来新建/etc/allowed_users这个文件 vi /etc/allowed_users加上uftp这个用户 到此为止，配置ftp server差不多结束了，我们最后验证下 sudo service vsftpd restartstop: Unknown instance ftp 127.0.0.1ftp: connect refused vsftpd /etc/vsftpd.conf500 OOPS: bad bool value in config file for: userlist_enable 尝试了3种验证方式，都失败了，根据最后一行的显示，应该是配置文件里面userlist_enable这个配置错了，找了半天，发现竟然是后面多了个空格引起的，好吧你赢了！更改之后，在尝试下ftp 127.0.0.1，就ok了 Connected to 127.0.0.1.220 (vsFTPd 3.0.2) 把nginx 日志文件找到，copy到／home/utfp里这个ubuntu有点妖，感觉路径都不对的，只好去／etc/nginx/sites-available里面找配置文件了 access_log /var/log/nginx/blog_access.log;error_log /var/log/nginx/blog_error.log; 好吧，去把这个blog_access.log拷贝到/home/uftp里面去 cp /var/log/nginx/blog_access.log /home/uftp 在mac上连接查看","categories":[{"name":"linux","slug":"linux","permalink":"http://saintyun.cn/categories/linux/"}],"tags":[{"name":"ftp","slug":"ftp","permalink":"http://saintyun.cn/tags/ftp/"},{"name":"linux","slug":"linux","permalink":"http://saintyun.cn/tags/linux/"}]},{"title":"Mac下用idea跑tomcat的又一个坑","slug":"Mac-idea-tomcat","date":"2017-04-10T06:11:57.000Z","updated":"2017-04-12T05:42:38.000Z","comments":true,"path":"2017/04/10/Mac-idea-tomcat/","link":"","permalink":"http://saintyun.cn/2017/04/10/Mac-idea-tomcat/","excerpt":"上次不是到bin文件夹下，把catalina.sh chmod a+x就好了么，这次又出现了一个很奇怪的错误： IntelliJ IDE运行Tomcat报错：Error: Exception thrown by the agent : java.net.MalformedURLException: Local host name unknown: java.net.UnknownHostException: XXXX: XXXX: nodename nor servname provided, or not known","text":"上次不是到bin文件夹下，把catalina.sh chmod a+x就好了么，这次又出现了一个很奇怪的错误： IntelliJ IDE运行Tomcat报错：Error: Exception thrown by the agent : java.net.MalformedURLException: Local host name unknown: java.net.UnknownHostException: XXXX: XXXX: nodename nor servname provided, or not known 一开始以为是端口占用问题，换了个jmx端口，也不行，后来一查，是因为没有设置过主机名称的原因。注意要用root权限去输入一下命令，如果不是，请输入sudo -i转成root先查看主机名称是否存在 scutil –get HostName 如果没有，我们自己设置一个 scutil –set HostName “localhost” 然后就ok～～～本着求知的精神，探讨一下，为什么linux系统或者mac系统下的idea tomcat会出现这样的情况？？？原来，由于Tomcat默认关闭JMX功能，但IntelliJ IDE配置的IDE需要提供JMX功能，所以IntelliJ IDE运行Tomcat报错：Unable to ping server at localhost:1099！那么JMX到底是什么，有什么作用?怎么在tomcat里面打开呢？ JMX是什么？ JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理。这是官方文档上的定义，我看过很多次也无法很好的理解。我个人的理解是JMX让程序有被管理的功能，例如你开发一个WEB网站，它是在24小时不间断运行，那么你肯定会对网站进行监控，如每天的UV、PV是多少；又或者在业务高峰的期间，你想对接口进行限流，就必须去修改接口并发的配置值。 JMX对于tomcat有什么作用笼统的说,JMX是管理资源的，可以对服务器进行资源的监视 举例来说，一个公司内部可能有许多应用服务器、若干Web服务器、一台至多台的数据库服务器及文件服务器等等，那么，如果我们想监视数据库服务器的内存使用情况，或者我们想更改应用服务器上JDBC最大连接池的数目，但我们又不想重启数据库和应用服务器，这就是典型意义上的资源管理，即对我们的资源进行监视(Monitoring，查看)和管理(Management，更改)，这种监视和更改不妨碍当前资源的正常运行。对资源进行适当的监测和管理，可以让我们的IT资源尽可能的平稳运行，可以为我们的客户提供真正意思上的24×7服务。在资源耗尽或者在硬件出故障之前，我们就可以通过管理工具监测到，并通过管理工具进行热调整和插拔。 如图所示是jconsole的可视化界面，由jdk/bin/jconsole.exe打开，我们可以连接我们的项目localhost:1099（jmx端口查看资源分配）下次如果有时间，可以去弄一下小🌰，去玩一玩这个jmx mac如何在tomcat里打开JMX?这篇博文写的很全了，自己去看看吧！http://blog.csdn.net/liang_love_java/article/details/50527441","categories":[{"name":"java","slug":"java","permalink":"http://saintyun.cn/categories/java/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://saintyun.cn/tags/tomcat/"}]},{"title":"在Mac下的tomcat出现error13错误","slug":"mac-tomcat-error13","date":"2017-04-07T08:20:48.000Z","updated":"2017-04-17T12:56:49.000Z","comments":true,"path":"2017/04/07/mac-tomcat-error13/","link":"","permalink":"http://saintyun.cn/2017/04/07/mac-tomcat-error13/","excerpt":"今天把自己所需要的公司的项目从thinkpad上全部迁移到自己的mac上来，一顿配置操作之后，运行时，发现报错了 tomcat error=13, permission denied 好吧，permission denied，应该是权限不够了，所以 解决办法: 打开terminal，找到tomcat下的catalina.sh,然后chmod a+x catalina.sh即可 你要问我为什么这么做就好了？？？","text":"今天把自己所需要的公司的项目从thinkpad上全部迁移到自己的mac上来，一顿配置操作之后，运行时，发现报错了 tomcat error=13, permission denied 好吧，permission denied，应该是权限不够了，所以 解决办法: 打开terminal，找到tomcat下的catalina.sh,然后chmod a+x catalina.sh即可 你要问我为什么这么做就好了？？？那只能补一下linux chmod命令了： chmod:change mode 改变一个或者多个文件的存取模式chmod [options] mode files 只能文件属主或特权用户才能使用该功能来改变文件存取模式。mode可以是数字形式或以who opcode permission形式表示。who是可选的，默认是a(所有用户)。只能选择一个opcode(操作码)。可指定多个mode，以逗号分开。 options： -c，–changes只输出被改变文件的信息 -f，–silent，–quiet当chmod不能改变文件模式时，不通知文件的用户 –help输出帮助信息。 -R，–recursive可递归遍历子目录，把修改应到目录下所有文件和子目录 –reference=filename参照filename的权限来设置权限 -v，–verbose无论修改是否成功，输出每个文件的信息 –version输出版本信息。 who u用户 g组 o其它 a所有用户(默认) opcode +增加权限 -删除权限 =重新分配权限 permission r读 w写 x执行 s设置用户(或组)的ID号 t设置粘着位(sticky bit)，防止文件或目录被非属主删除 u用户的当前权限 g组的当前权限 o其他用户的当前权限 作为选择，我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。 还可设置第四位，它位于三位权限序列的前面，第四位数字取值是4，2，1，代表意思如下： 4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。 2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。 1，设置粘着位。 实例： $ chmod u+x file 给file的属主增加执行权限$ chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限$ chmod u=rwx,g=rx,o=x file 上例的另一种形式$ chmod =r file 为所有用户分配读权限$ chmod 444 file 同上例$ chmod a-wx,a+r file 同上例$ chmod -R u+r directory 递归地给directory目录下所有文件和子目录的属主分配读的权限$ chmod 4755 设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。 好吧，之前接触过 chmod 777 filer表是读 (Read) 、w表示写 (Write) 、x表示执行 (eXecute)读、写、运行三项权限可以用数字表示，就是r=4,w=2,x=1，777就是rwxrwxrwx，意思是该登录用户（可以用命令id查看）、他所在的组和其他人都有最高权限。","categories":[{"name":"linux","slug":"linux","permalink":"http://saintyun.cn/categories/linux/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://saintyun.cn/tags/tomcat/"}]},{"title":"FileNotFoundExeption cant find WEB-INF/application.xml错误","slug":"FileNotFoundExeption-cant-find-WEB-INF-application-xml","date":"2017-04-05T07:23:54.000Z","updated":"2017-04-12T05:41:55.000Z","comments":true,"path":"2017/04/05/FileNotFoundExeption-cant-find-WEB-INF-application-xml/","link":"","permalink":"http://saintyun.cn/2017/04/05/FileNotFoundExeption-cant-find-WEB-INF-application-xml/","excerpt":"在idea里面新导入一个eclipse项目，结果要配置的有很多，具体都都是些小问题，主要有以下几项问题 问题1.能正常部署，但是404错误，output里的web.xml内容为空如图所示，画红圈的地方需要注意","text":"在idea里面新导入一个eclipse项目，结果要配置的有很多，具体都都是些小问题，主要有以下几项问题 问题1.能正常部署，但是404错误，output里的web.xml内容为空如图所示，画红圈的地方需要注意 问题2.start server后，找不到WEB-INF/application.xml需要在配置文件web.xml里面加入如下语句来指定路径： contextConfigLocation classpath:applicationContext.xml 还有一些要注意的地方 好吧，这篇文章也算是hexo上传图片的尝试~~ ![alt text](https://github.com/yourname/respname/raw/master/image/XXX.png “title”) 逃~~","categories":[{"name":"java","slug":"java","permalink":"http://saintyun.cn/categories/java/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://saintyun.cn/tags/idea/"},{"name":"spring","slug":"spring","permalink":"http://saintyun.cn/tags/spring/"}]},{"title":"android studio build gradle info卡住","slug":"android-studio-build-lag-problem","date":"2017-04-05T06:12:22.000Z","updated":"2017-04-17T13:06:00.000Z","comments":true,"path":"2017/04/05/android-studio-build-lag-problem/","link":"","permalink":"http://saintyun.cn/2017/04/05/android-studio-build-lag-problem/","excerpt":"问题1.android studio导入新项目时，一直卡在android studio build gradle info…这个界面最后查了一下，感觉应该是gradle下载问题，因为被墙，所以速度缓慢。 解决办法：","text":"问题1.android studio导入新项目时，一直卡在android studio build gradle info…这个界面最后查了一下，感觉应该是gradle下载问题，因为被墙，所以速度缓慢。 解决办法： 离线下载gradle包查看所需gradle版本：打开C:\\Users\\用户名.gradle\\wrapper\\dists\\gradle-x.xx-all\\xxxxxxxxxxxx，如果里面的gradle-xx-all.zip不完整（如0KB），则说明下载不成功，需要下载离线包放置到该目录下，那么，则需要下载gradle-2.8-all.zip。gradle各个版本离线包下载地址：http://download.csdn.net/album/detail/2265导入完成后，运行AS之后会自动解压，如下。重新打开项目就可以了~~ 修改gradle-wrapper.properties方式1、随便找一个你之前能够运行的AS项目2、打开项目的/gradle/wrapper/gradle-wrapper.properties文件3、复制最后一行distributionUrl这一整行的内容，例如：distributionUrl=https\\://services.gradle.org/distributions/gradle-2.8-all.zip，替换到你要导入的项目里的gradle-wrapper.properties文件中。4、重启Android Studio，重新导入项目就可以了~~ 问题2.Android Studio 导入项目 出现安装Error:Cause: failed to find target with hash string ‘android-17’ 等错误解决办法：在等了一段时间后，update下android sdk manager的列表之后，终于出现了需要的android api型号列，之后只要傻瓜操作，缺啥下啥就好了，最好有个科学上网工具～～","categories":[{"name":"android","slug":"android","permalink":"http://saintyun.cn/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://saintyun.cn/tags/android/"}]},{"title":"hexo tips","slug":"hexo-tips","date":"2017-04-05T04:13:17.000Z","updated":"2017-04-12T09:04:08.000Z","comments":true,"path":"2017/04/05/hexo-tips/","link":"","permalink":"http://saintyun.cn/2017/04/05/hexo-tips/","excerpt":"一些hexo的具体操作步骤以及命令tips下面介绍一些常用命令吧！！！！ 常用命令","text":"一些hexo的具体操作步骤以及命令tips下面介绍一些常用命令吧！！！！ 常用命令 hexo server:启动server hexo new draft :新建一个草稿 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish #hexo publish 草稿（_drafts -&gt; _posts） hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 _config.xml这里的配置主要配置下language,author,title等等，还有加入deploy的托管对象hexo支持多种deploy方式：git: deploy: type: git repo: https://github.com/GodIsMadao/hexo.git branch: master rsync: deploy: type: rsync host: 你 VPS 的 IP 地址或者域名 user: root root: 你想将 Hexo 生成的静态文件存放在 VPS 中的目录 例如: /www/hexo/blog/ port: 你 VPS 的 ssh 端口号 delete: true verbose: true ignore_errors: false Heroku: deploy: type: heroku repo: message: [message] OpenShift: deploy: type: openshift repo: message: [message] FTPSync: deploy: type: ftpsync host: user: pass: remote: [remote] port: [port] ignore: [ignore] connections: [connections] verbose: [true|false] 本来想用rsync的方式，直接连接vps的，但是port设置为自定义的貌似不可以（默认是22），他始终提示我port还是22，就是修改不了，最后干脆用git了。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://saintyun.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://saintyun.cn/tags/hexo/"}]},{"title":"hello myblog","slug":"hello-myblog","date":"2017-03-23T12:18:49.000Z","updated":"2017-04-17T13:05:39.000Z","comments":true,"path":"2017/03/23/hello-myblog/","link":"","permalink":"http://saintyun.cn/2017/03/23/hello-myblog/","excerpt":"","text":"你好，欢迎来到我的个人技术博客。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://saintyun.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://saintyun.cn/tags/hexo/"}]}]}